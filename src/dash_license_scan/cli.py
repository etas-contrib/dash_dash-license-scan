import argparse
import sys
from collections.abc import Sequence
from dataclasses import dataclass
from logging import getLogger
from pathlib import Path

from dash_license_scan import __version__, jar

log = getLogger(__name__)


@dataclass
class Params:
    dry_run: bool
    pypi: list[Path]
    crate: list[Path]
    passthrough: list[str]


def build_parser() -> argparse.ArgumentParser:
    p = argparse.ArgumentParser(
        description=f"Wrapper around eclipse-dash/dash-licenses.\nUses bundled {jar.get_jar().name}.",
    )
    p.add_argument(
        "--version",
        action="version",
        version=f"%(prog)s {__version__}",
    )
    p.add_argument(
        "--dry-run",
        action="store_true",
        help="Print the constructed eclipse-dash command without executing it",
    )
    p.add_argument(
        "--pypi",
        help="Path to pip requirements.txt as generated by pip freeze or pip-compile",
        type=Path,
    )
    p.add_argument(
        "--crate",
        help="Path to Cargo.lock as generated by Cargo",
        type=Path,
    )
    p.add_argument("passthrough", nargs=argparse.REMAINDER, help="Arguments after -- are passed to dash-licenses JAR")

    return p


def parse_args(argv: Sequence[str] | None = None):
    parser = build_parser()
    args = parser.parse_args(argv)

    # Check if all unparsed args are aimed at passthrough
    if args.passthrough and args.passthrough[0] != "--":
        sys.exit(f"Error: unrecognized arguments: {args.passthrough}")

    return Params(
        dry_run=args.dry_run,
        pypi=[args.pypi] if args.pypi else [], # FIXME allow multiple
        crate=[args.crate] if args.crate else [], # FIXME allow multiple
        passthrough=args.passthrough[1:] if args.passthrough else [],
    )
